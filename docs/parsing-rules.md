# URL & QueryString 파싱 규칙 정의서

이 문서는 URL & QueryString Parser의 모든 파싱 규칙과 동작 방식을 정의합니다.

## 📋 목차

1. [플래그 규칙](#플래그-규칙)
2. [타입 규칙](#타입-규칙)
3. [처리 모드 규칙](#처리-모드-규칙)
4. [값 우선순위 규칙](#값-우선순위-규칙)
5. [유효성 검증 규칙](#유효성-검증-규칙)
6. [전역 플래그 규칙](#전역-플래그-규칙)
7. [URL 세그먼트 규칙](#url-세그먼트-규칙)
8. [쿼리 파라미터 규칙](#쿼리-파라미터-규칙)

---

## 플래그 규칙

### 기본 플래그

| 플래그 | 의미 | 설명 |
|--------|------|------|
| `e` | encrypted | 암호화 대상으로 표시 |
| `r` | required | 필수값으로 표시 |
| `v` | literal | 리터럴 값 (변환하지 않고 그대로 사용) |

### 플래그 조합 규칙

1. **순서 무관**: `er{값}`, `re{값}`, `erv{값}` 모두 동일하게 처리
2. **중복 허용**: `ee{값}` → `e{값}`과 동일 (중복된 플래그는 무시)
3. **알 수 없는 플래그 무시**: `ex{값}` → `e{값}`과 동일 (`x`는 무시)

### 플래그 우선순위

1. **`v` (literal) 최우선**: 다른 모든 타입 감지를 무시하고 리터럴로 처리
2. **`e` (encrypted)**: 최종 값에 암호화 적용
3. **`r` (required)**: 필수값 표시 (현재 구현에서는 추적용)

```typescript
// 예시
v{A_TYPE_1}  // → 타입: LITERAL, 값: "A_TYPE_1" (변환 안함)
e{A_TYPE_1}  // → 타입: A, 값: A_TYPE_1_VALUE → 암호화
ev{A_TYPE_1} // → 타입: LITERAL, 값: "A_TYPE_1" → 암호화 (v가 우선)
```

---

## 타입 규칙

### 타입 종류

| 타입 | 설명 | 변환 방법 |
|------|------|-----------|
| `A` | A타입 값 (ATYPE_VALUES 배열에 포함) | TypeConverter 호출 |
| `B` | B타입 값 (BTYPE_VALUES 배열에 포함) | TypeConverter 호출 |
| `LITERAL` | 리터럴 값 (v 플래그 사용) | 변환하지 않음 |
| `UNKNOWN` | 알 수 없는 타입 | 변환하지 않음 |
| `GLOBAL` | 전역 쿼리 | 특별 처리 |

### 타입 결정 규칙

1. **`v` 플래그 우선**: `v` 플래그가 있으면 무조건 `LITERAL` 타입
2. **A타입 검사**: ATYPE_VALUES 배열에 포함되면 `A` 타입
3. **B타입 검사**: BTYPE_VALUES 배열에 포함되면 `B` 타입
4. **기본값**: 위 조건에 해당하지 않으면 `UNKNOWN` 타입

```typescript
// 현재 정의된 타입 값들
ATYPE_VALUES = ['A_TYPE_1', 'A_TYPE_2', 'A_TYPE_3', 'A_TYPE_4', 'A_TYPE_5', 'PROC', 'NAME']
BTYPE_VALUES = ['B_TYPE_1', 'B_TYPE_2', 'B_TYPE_3', 'B_TYPE_4']
```

---

## 처리 모드 규칙

### 모드 구분

| 모드 | 설명 | 패턴 | 예시 |
|------|------|------|------|
| `PARAMETER` | 값 사용 모드 | `[플래그]{값}` | `name=e{A_TYPE_1}` |
| `SUBSTITUTION` | 문자열 치환 모드 | 복잡한 구조 | `where=PROC=!@r{NAME}` |

### 모드 감지 규칙

1. **정규식 검사**: `^[erv]*\{[^{}]+\}$` 패턴에 맞는지 확인
2. **중첩 검사**: 중괄호 안에 다른 중괄호가 있는지 확인
3. **결정 로직**:
   - 정규식 매칭 + 중첩 없음 → `PARAMETER` 모드
   - 그 외 모든 경우 → `SUBSTITUTION` 모드

```typescript
// PARAMETER 모드 예시
"e{A_TYPE_1}"     // ✅ 단순 패턴
"{B_TYPE_2}"      // ✅ 플래그 없어도 단순 패턴
"v{LITERAL}"      // ✅ 리터럴 단순 패턴

// SUBSTITUTION 모드 예시
"PROC=!@r{NAME}"          // ❌ 복잡한 구조
"v{TEXT}.com"             // ❌ 중괄호 외부에 추가 문자
"e{NAME=r{VALUE}}"        // ❌ 중첩 중괄호
```

---

## 값 우선순위 규칙

### 6단계 우선순위

| 순위 | 값 | 조건 | 설명 |
|------|-----|------|------|
| 1 | `encryptedValue` | `!== null` | 암호화된 값 (최우선) |
| 2 | `convertedValue` | `!== null` | 타입 변환된 값 |
| 3 | `extractedValue` | `flags.literal && !== null` | 리터럴 값 |
| 4 | `''` | `SUBSTITUTION && !literal && !converted` | 치환 모드 빈 값 |
| 5 | `''` | `PARAMETER && !literal && !converted` | 파라미터 모드 빈 값 |
| 6 | `originalValue` | 기본값 | 원본 값 (fallback) |

### 모드별 빈 값 처리

**PARAMETER 모드**: 빈 값이면 파라미터 전체 제외
```typescript
// 입력: ?name={UNKNOWN}&valid=test
// 결과: ?valid=test  (name 파라미터 완전 제거)
```

**SUBSTITUTION 모드**: 빈 값이면 해당 부분만 빈 문자열로 치환
```typescript
// 입력: where=PROC=!@{UNKNOWN}
// 결과: where=PROC=!@  (해당 부분만 제거)
```

---

## 유효성 검증 규칙

### 유효성 판단 기준

| 조건 | 결과 | 이유 |
|------|------|------|
| `SUBSTITUTION` 모드 | 항상 유효 | 문자열 구조 보존 필요 |
| `flags.literal` | 항상 유효 | 사용자 명시적 의도 존중 |
| `UNKNOWN + !convertedValue` | 무효 | 변환 불가능 |
| `(A\|B) + !convertedValue` | 무효 | 변환 실패 |
| 기타 | 유효 | 정상 처리 |

### 최종 URL 포함 규칙

1. **유효한 값**: 최종 URL에 포함
2. **무효한 값**: 최종 URL에서 제외
3. **리터럴 값**: 빈 값이라도 항상 포함 (사용자 의도)
4. **치환 모드**: 빈 값이라도 항상 포함 (문자열 구조 보존)

---

## 전역 플래그 규칙

### 전역 플래그 감지

- **패턴**: 쿼리스트링 전체가 `^[erv]*\{(.+)\}$` 형태
- **조건**: 하나 이상의 플래그가 실제로 설정되어야 함

### 전역 플래그 처리 과정

1. **1단계**: 내부 쿼리들을 개별 파싱 및 변환
2. **2단계**: 변환된 결과들을 `key=value&key=value` 형태로 재구성
3. **3단계**: 전체 문자열에 전역 플래그 적용 (암호화 등)

```typescript
// 예시: ?e{name={A_TYPE_1}&value=test}
// 1단계: name=A_TYPE_1_VALUE&value=test
// 2단계: 전체 문자열 암호화
// 3단계: ?ENCRYPTED_STRING
```

### 전역 vs 일반 차이점

| 구분 | 일반 플래그 | 전역 플래그 |
|------|-------------|-------------|
| 적용 범위 | 개별 파라미터 | 쿼리스트링 전체 |
| 처리 단계 | 1단계 | 2단계 |
| 최종 형태 | `?key=value&key=value` | `?encrypted_string` |
| 보안 수준 | 개별 암호화 | 이중 암호화 |

---

## URL 세그먼트 규칙

### 세그먼트 정의

- URL 경로를 `/`로 분할한 각각의 부분
- 예: `/users/123/profile` → `["users", "123", "profile"]`

### 세그먼트 처리 규칙

1. **개별 처리**: 각 세그먼트는 독립적으로 파싱 및 변환
2. **모드 적용**: 파라미터 모드와 치환 모드 모두 지원
3. **재구성**: 변환된 세그먼트들을 `/`로 다시 연결

### 세그먼트 예시

```typescript
// 입력: /e{A_TYPE_1}/r{B_TYPE_2}/profile
// 처리: 
//   - 세그먼트 0: e{A_TYPE_1} → A_TYPE_1_VALUE(암호화됨)
//   - 세그먼트 1: r{B_TYPE_2} → B_TYPE_2_VALUE
//   - 세그먼트 2: profile → profile (변경 없음)
// 결과: /ENCRYPTED_VALUE/B_TYPE_2_VALUE/profile
```

---

## 쿼리 파라미터 규칙

### 파라미터 파싱

1. **스마트 분할**: 중괄호 안의 `&`는 구분자로 인식하지 않음
2. **키-값 분리**: `=`를 기준으로 키와 값 분리
3. **재귀 처리**: 중첩된 구조는 재귀적으로 파싱

### 안전한 쿼리 분할

```typescript
// 문제 상황: "name={A&B}&value=test"
// 일반 split('&'): ["name={A", "B}", "value=test"] ❌
// 스마트 분할: ["name={A&B}", "value=test"] ✅
```

### 쿼리 재구성 규칙

1. **유효한 파라미터만**: `isValidValue()` 통과한 것만 포함
2. **전역 쿼리 특별 처리**: 키 없이 값만 포함
3. **일반 쿼리**: `key=value` 형태로 포함

---

## 💡 핵심 설계 원칙

### 1. 사용자 의도 존중
- `v` 플래그 사용시 무조건 리터럴 처리
- 빈 값이라도 명시적 의도면 포함

### 2. 안전한 기본값
- 알 수 없는 것은 변환하지 않음
- 실패시 원본 값 보존

### 3. 모드별 차별화
- PARAMETER: 엄격한 검증 (깔끔한 URL)
- SUBSTITUTION: 관대한 검증 (구조 보존)

### 4. 단계적 처리
- 파싱 → 변환 → 검증 → 재구성
- 각 단계별 명확한 책임 분리

### 5. 확장 가능성
- 새로운 플래그 추가 용이
- 새로운 타입 추가 용이
- 새로운 처리 모드 추가 용이

---

## 📝 변경 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|-----------|
| 1.0 | 2025-01-25 | 최초 규칙 정의서 작성 |

---

이 문서는 URL & QueryString Parser의 모든 동작을 정의하며, 새로운 기능 추가나 수정시 이 규칙을 준수해야 합니다.